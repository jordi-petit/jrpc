import type { OpenJRPC, FunctionJRPC, ModuleJRPC } from '@/openjrpc'
import type { TSchema } from 'elysia'

export function genPython(openjrpc: OpenJRPC) {
    const preamble = `

# ${openjrpc.title} ${openjrpc.version}
# Autogenerated by OpenJRPC


import requests
import json
from typing import Any, TypedDict


def _execute(name: str, arg: Any) -> Any:
    response = requests.post('http://localhost:8000/jrpc', json={"name": name, "arg": arg})
    result = response.json()
    if result['error']:
        raise Exception(result['error'])
    # estaria bé verificar aquí que el tipus retornat compleix amb el promès (l'API ja ho fa però així el client també en tindria la seguretat)
    return result['result']


`

    return preamble + genPythonModule(openjrpc.root, true)
}

function genPythonModule(module: ModuleJRPC, root: boolean = false): string {
    const functions = module.functions.map(func => genPythonFunction(func, root))
    const modules = module.submodules.map(genPythonSubModule)

    return functions.join('\n') + modules.join('\n')
}

function genPythonFunction(func: FunctionJRPC, root: boolean = false): string {
    const { name, input, output, summary, description } = func

    return `

${root ? '' : '@staticmethod'}
def ${name} (arg: ${typify(input)}) -> ${typify(output)}:
    """
        ${summary || 'No summary'}

        ${description || 'No description'}
    """

    return _execute('${name}', arg)

    `
}

function genPythonSubModule(mod: ModuleJRPC): string {
    const module = genPythonModule(mod)

    return `

class ${mod.name}:

${indent(module)}

    `
}


function indent(s: string): string {
    return s.split('\n').map((line) => ' '.repeat(4) + line).join('\n')
}


function typify(schema: TSchema): string {
    // segur que alguna llibreria ja fa això millor
    if (schema.type === 'object') {
        const props = Object.entries(schema.properties)
            .map(([key, value]: any) => `'${key}': ${typify(value)} `)
            .join(', ')
        return `{${props} } `
    }
    if (schema.type === 'array') {
        return `list[${typify(schema.items)}]`
    }
    if (schema.type === 'string') {
        return 'str'
    }
    if (schema.type === 'number') {
        return 'float'
    }
    if (schema.type === 'integer') {
        return 'int'
    }
    if (schema.type === 'boolean') {
        return 'bool'
    }
    throw new Error(`Type ${schema.type} not supported`)
}
